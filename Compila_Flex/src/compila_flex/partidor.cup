package compila_flex;

import java.io.*;
import java_cup.runtime.*;
import java.util.*;

parser code
{:
    public static Nodo arbol;
         /**
     * Método al que se llama automáticamente ante algún error sintactico.
     **/ 
    public void syntax_error(Symbol s){ 
       System.out.println("Error Sintáctico en la Columna " + (s.left) +
        " linear "+s.right+ ". No se esperaba este componente: " +s.value+".");
       System.out.println("Sintaxis malo malo malo");
    } 

    /**
     * Método al que se llama automáticamente ante algún error sintáctico 
     * en el que ya no es posible una recuperación de errores.
     **/ 
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error síntactico irrecuperable en la columna " + 
        (s.left)+ " linear "+s.right+". Componente " + s.value + 
        " no reconocido.");
        System.out.println("Sintaxis MAL irrecuperable"); 
    }  
    
:}

action code 
{:
    Nodo arbol;
    int token=0;
    int parNum=0;
:}


//lexemas
terminal  VERDAD, NUMERITO, LETRA,WORD;


//palabras reservadas y Operadores

terminal PUNTOC, PARENTESISA, PARENTESISC, ABRIRC, CERRARC , ASSIGNMENT, BRACKETA, BRACKETC, COMMA;
terminal OPER, OPEA_SUM, OPEA_MULT, BOOL,  FOR, WLE, IF, EIF, ELSE ,BLOCK, END;
terminal NUM, LETTER, FUNC, START ,FLECHA,  VAR ,  NOT;
terminal IN, PUNTO, CASE,DEFAULT, REPLY, ID;
terminal ARRAY,NEW;
terminal THROW,THROWDOWN,CATCH;

//not terminales
non terminal Program;
non terminal ifState;
non terminal expression;
non terminal valores;
non terminal type;
non terminal body;
non terminal parametro;
//non terminal declara;
non terminal declara_puntoc;
non terminal declara_array;
non terminal declara_simple;
non terminal eif;
non terminal proposition;
non terminal asigna;
non terminal CicloFor;
non terminal funciones;
non terminal expression_simple;
non terminal termino;
non terminal signo;
non terminal factor;
//non terminal factor_for;
non terminal list_expression;
non terminal block_switch;
non terminal cases;
non terminal vacio;
non terminal print;
non terminal catch;

start with Program;

//program------------------------------------------------------------------
Program ::= START FLECHA BRACKETA body:b BRACKETC
{:
    token ++;
    Nodo start = new Nodo("Start",null,token);
    token ++;
    Nodo flecha = new Nodo("->",null,token);
    token ++;
    Nodo Braca = new Nodo("[",null,token);

    token ++;
    Nodo Bracc = new Nodo("]",null,token);
    start.addHijo(flecha);
    start.addHijo(Braca);
    start.addHijo((Nodo)b);
    start.addHijo(Bracc);
    parser.arbol = start;
    // RESULT = b;
:};

//declara ::= VAR type ID ASSIGNMENT  valores  PUNTOC;

//Declaracion------------------------------------------------------------------
declara_simple::= VAR type:t ID:id declara_puntoc:d
{:
    //no estoy seguro de como declarar id
    token++;
    Nodo decla = new Nodo("Declaracion",null,token);
    token++;
    Nodo var = new Nodo("VAR",null,token);
    decla.addHijo(var);
    decla.addHijo((Nodo)t);
    token++;
    Nodo i = new Nodo("ID",null,token);
    decla.addHijo(i);
    decla.addHijo((Nodo)d);
    // Nodo node = new Nodo("Id",null,token);
    // decla.addHijo(node);
    // RESULT = node;

    
:};
//Funcion------------------------------------------------------------------
funciones::= FUNC type:tipo ID PARENTESISA parametro:par PARENTESISC BRACKETA body:bod REPLY PARENTESISA parametro:para PARENTESISC BRACKETC
{:
    token++;
    Nodo f = new Nodo("Funcion",null,token);
    token++;
    Nodo t = new Nodo("tipo",null,token);
    f.addHijo(t);
    token++;
    Nodo i = new Nodo("ID",null,token);
    f.addHijo(i);
    token++;
    Nodo parenA = new Nodo("(",null,token); 
    f.addHijo(parenA);
    
    f.addHijo((Nodo)par);

    token++;
    Nodo parenC = new Nodo(")",null,token);
    f.addHijo(parenC);
    token++;
    Nodo brackA = new Nodo("[",null,token);
    f.addHijo(brackA);
    token++;
    f.addHijo((Nodo)bod);
    token++;
    Nodo rep = new Nodo("Reply",null,token); 
    f.addHijo(rep);
    token++;
    Nodo parenA2 = new Nodo("(",null,token); 
    f.addHijo(parenA2);
    
    f.addHijo((Nodo)para);

    token++;
    Nodo parenC2 = new Nodo(")",null,token);
    f.addHijo(parenC2);
    token++;
    Nodo brackC = new Nodo("]",null,token);
    f.addHijo(brackC);
:};
//For------------------------------------------------------------------
CicloFor::= FOR PARENTESISA ID IN NUM PUNTO PUNTO PUNTO NUM PARENTESISC FLECHA ABRIRC body CERRARC
{:

:};
//body------------------------------------------------------------------
body::= proposition:p body:b
{:
    token++;
    Nodo node = new Nodo("Body",null,0);
    node.addHijo((Nodo)p);
    node.addHijo((Nodo)b);
    RESULT = node;
:}
    |   funciones:f body:b
{:
    token++;
    Nodo node = new Nodo("Body",null,0);
    node.addHijo((Nodo)b);
    node.addHijo((Nodo)f);
    RESULT = node;
:}
    |   error body:b
{:
    token++;
    Nodo node = new Nodo("Body",null,0);
    node.addHijo("Error",token);
    node.addHijo((Nodo)b);
    RESULT = node;
:}
    | {::};
//parametro------------------------------------------------------------------
parametro::= type ID
    | ID;
//proposciones------------------------------------------------------------------
proposition::= WLE expression:ex FLECHA ABRIRC proposition:p CERRARC
{:
    token++;
    Nodo node = new Nodo("Proposicion",null,token);
    
    token++;
    Nodo w = new Nodo("WLE",null,token);
    node.addHijo(w);

    node.addHijo((Nodo)ex);

    token++;
    Nodo flech = new Nodo("->",null,token);
    node.addHijo(flech);

    token++;
    Nodo abC = new Nodo("<",null,token);
    node.addHijo(abC);

    node.addHijo((Nodo)p);

    token++;
    Nodo cerC = new Nodo(">",null,token);
    node.addHijo(cerC);

:}
    |   declara_simple:d
{:
    token++;
    Nodo node = new Nodo("Proposicion",null,token);
    node.addHijo((Nodo)d);
    RESULT = node;
:}
    |   CicloFor:cf
{:
    token++;
    Nodo node = new Nodo("Proposicion",null,token);
    node.addHijo((Nodo)cf);
:}
    |   ifState:is
{:
    token++;
    Nodo node = new Nodo("Proposicion",null,token);
    node.addHijo((Nodo)is);
:}
    |   ID ASSIGNMENT expression:ex PUNTOC
{:
    token++;
    Nodo node = new Nodo("Proposicion",null,token);

    token++;
    Nodo id = new Nodo("id",null,token);
    node.addHijo(id);

    token++;
    Nodo assign = new Nodo("=",null,token);
    node.addHijo(assign);

    node.addHijo((Nodo)ex);

    token++;
    Nodo punC = new Nodo(";",null,token);
    node.addHijo(punC);

    RESULT = node;
:}
    |   block_switch:bs
{:
    token++;
    Nodo node = new Nodo("Proposicion",null,token);
    node.addHijo((Nodo)bs);
:}
    |   print:p
{:
    token++;
    Nodo node = new Nodo("Proposicion",null,token);
    node.addHijo((Nodo)p);
:}
    |   catch:c
{:
    token++;
    Nodo node = new Nodo("Proposicion",null,token);
    node.addHijo((Nodo)c);
:};
//impresiones------------------------------------------------------------------
print::= THROW PARENTESISA ID PARENTESISC PUNTOC
{:
        
:}
    |   THROW PARENTESISA valores PARENTESISC PUNTOC
    |   THROWDOWN PARENTESISA ID PARENTESISC PUNTOC
    |   THROWDOWN PARENTESISA valores PARENTESISC PUNTOC;

//scanner------------------------------------------------------------------     
catch::= CATCH PARENTESISA ID COMMA ID PARENTESISC PUNTOC;

//tipo------------------------------------------------------------------
type::= VERDAD
{:
    token++;
    Nodo type = new Nodo("type",null,token);
    token++;
    Nodo node = new Nodo("Bool", null, token);
    type.addHijo(node);
    RESULT = node;
    
:}
    | NUMERITO
{:
    token++;
    Nodo type = new Nodo("type",null,token);
    token++;
    Nodo node = new Nodo("Num", null, token);
    type.addHijo(node);
    RESULT = node;
:}
    | LETRA
{:
    token++;
    Nodo type = new Nodo("type",null,token);
    token++;
    Nodo node = new Nodo("Letter", null, token);
    type.addHijo(node);
    RESULT = node;
:}
    | WORD
{:
    token++;
    Nodo type = new Nodo("type",null,token);
    token++;
    Nodo node = new Nodo("Word", null, token);
    type.addHijo(node);
    RESULT = node;
:};

//declara puntoC------------------------------------------------------------------
declara_puntoc::= PUNTOC
{:
    token++;
    Nodo node = new Nodo(";", null, token);
    RESULT = node;
:}
    |   asigna: as
{:
    token++;
    Nodo asigna = new Nodo("asigna",null,token);
    asigna.addHijo((Nodo)as);
    RESULT = asigna;
:};

//asignacion------------------------------------------------------------------
asigna::= ASSIGNMENT valores:valor PUNTOC
{:
    token++;
    Nodo node = new Nodo("assigan",null,token);

    token++;
    Nodo assign = new Nodo("Assigment",null,token);
    node.addHijo(assign);

    node.addHijo((Nodo)valor);

    token++;
    Nodo pun = new Nodo(";", null, token);
    node.addHijo(pun);
    RESULT = node;
:}
    |   ASSIGNMENT ID PUNTOC
{:
    token++;
    Nodo node = new Nodo("assigan",null,token);
    
    token++;
    Nodo assign = new Nodo("ASSIGMENT",null,token);
    node.addHijo(assign);

    token++;
    Nodo id = new Nodo("ID",null,token);
    node.addHijo(id);

    token++;
    Nodo pun = new Nodo(";",null,token);
    node.addHijo(pun);

    RESULT = node;
:}
    |   vacio PUNTOC
{:
    token++;
    Nodo node = new Nodo("assigan",null,token);

    token++;
    Nodo pun = new Nodo(";",null,token);
    node.addHijo(pun);
    
    RESULT = node;
:};

//array------------------------------------------------------------------
declara_array::= VAR ID:ide ASSIGNMENT NEW ARRAY PARENTESISA NUM:num PARENTESISC BRACKETA type:tipo BRACKETC
{:
    token++;
    Nodo declara = new Nodo("declaraArray",null,token);

    token++;
    Nodo v = new Nodo("var",null,token);
    declara.addHijo(v);

    token++;
    Nodo id = new Nodo("ID",null,token);
    token++;
    id.addHijo(ide.toString(),token);
    declara.addHijo(id);
    
    token++;
    Nodo ass = new Nodo("assignment",null,token);
    declara.addHijo(ass);
    
    token++;
    Nodo n = new Nodo("new",null,token);
    declara.addHijo(n);

    token++;
    Nodo ar = new Nodo("array",null,token);
    declara.addHijo(ar);

    token++;
    Nodo parA = new Nodo("(",null,token);
    declara.addHijo(parA);
    
    token++;
    Nodo nu = new Nodo("num",null,token);
    token++;
    nu.addHijo(num.toString(),token);
    declara.addHijo(nu);


    token++;
    Nodo parC = new Nodo(")",null,token);
    declara.addHijo(parC);

    token++;
    Nodo braA = new Nodo("[",null,token);
    declara.addHijo(braA);
    
    declara.addHijo((Nodo)tipo);

    token++;
    Nodo braC = new Nodo("]",null,token);
    declara.addHijo(braC);

    RESULT = declara;
:};

//valores------------------------------------------------------------------
valores::= NUM
{:
    token++;
    Nodo val = new Nodo("valores",null,token);
    
    token++;
    Nodo num = new Nodo("num",null,token);
    val.addHijo(num);
    
    RESULT = val;
:}
    |   BOOL
{:
    token++;
    Nodo val = new Nodo("valores",null,token);

    token++;
    Nodo bool = new Nodo("Bool",null,token);
    val.addHijo(bool);
    
    RESULT = val;
:}
    |   LETTER
{:
    token++;
    Nodo val = new Nodo("valores",null,token);
    
    token++;
    Nodo let = new Nodo("letter",null,token);
    val.addHijo(let);
    
    RESULT = val;
:};

//if------------------------------------------------------------------

ifState::= IF PARENTESISA expression:ex PARENTESISC ABRIRC proposition:pro CERRARC eif: ei
{:
    token++;
    Nodo sIf = new Nodo("ifState",null,token);

    token++;
    Nodo f = new Nodo("if",null,token);
    sIf.addHijo(f);

    token++;
    Nodo parA = new Nodo("(",null,token);
    sIf.addHijo(parA);
    
    
    sIf.addHijo((Nodo)ex);

    token++;
    Nodo parC = new Nodo(")",null,token);
    sIf.addHijo(parC);
    
    token++;
    Nodo abC = new Nodo("<",null,token);
    sIf.addHijo(abC);
    
    sIf.addHijo((Nodo)pro);

    token++;
    Nodo verC = new Nodo(">",null,token);
    sIf.addHijo(verC);
    
    sIf.addHijo((Nodo)ei);

    RESULT = sIf;
    
:};

//Elseif--------------------------------------------------------------
eif::= EIF expression:ex ABRIRC proposition:p CERRARC eif:e2
{:
    token++;
    Nodo ei = new Nodo("ElseIf",null,token);

    token++;
    Nodo e = new Nodo("eif",null,token);
    ei.addHijo(e);
    
    ei.addHijo((Nodo)ex);
    
    token++;
    Nodo abC = new Nodo("<",null,token);
    ei.addHijo(abC);
    
    ei.addHijo((Nodo)p);
    
    token++;
    Nodo ceC = new Nodo(">",null,token);
    ei.addHijo(ceC);

    ei.addHijo((Nodo)e2);

    RESULT = ei;

:}
    |   ELSE ABRIRC proposition:p CERRARC
{:
    token++;
    Nodo ei = new Nodo("ElseIf",null,token);

    token++;
    Nodo el = new Nodo("e",null,token);
    ei.addHijo(el);
    
    ei.addHijo((Nodo)p);
    
    token++;
    Nodo ceC = new Nodo(">",null,token);
    ei.addHijo(ceC);
    
    RESULT = ei;
:}
    |   {::};

//bloque switch------------------------------------------------------------------
block_switch::= BLOCK PARENTESISA ID PARENTESISC FLECHA cases END;

cases::= CASE ID ABRIRC body CERRARC cases
    |   CASE valores ABRIRC body CERRARC cases
    |   DEFAULT ABRIRC body CERRARC ;
//expresiones------------------------------------------------------------------
expression::= expression_simple:exp
{:
    token++;
    Nodo expression=new Nodo("Expression",null,token);

    expression.addHijo((Nodo)exp);

    RESULT = expression;
:}
    |   expression_simple:expS OPER:op expression:exp
    
{:
    token++;
    Nodo expression=new Nodo("Expression",null,token);

    expression.addHijo((Nodo)expS);

    expression.addHijo((Nodo)op);

    expression.addHijo((Nodo)exp);

    RESULT = expression;
:};

expression_simple::= termino:t
{:
    token++;
    Nodo expression=new Nodo("ExpressionSimple",null,token);

    expression.addHijo((Nodo)t);
    
    RESULT = expression;
:}
    |   signo:s termino:t
{:
    token++;
    Nodo expression=new Nodo("ExpressionSimple",null,token);
    
    expression.addHijo((Nodo)s);
    
    expression.addHijo((Nodo)t);

    RESULT = expression;
:}
    |   expression_simple:expS OPEA_SUM:op termino:t
{:
    token++;
    Nodo expression=new Nodo("ExpressionSimple",null,0);
    
    expression.addHijo((Nodo)expS);
    
    token++;
    Nodo opea_sum= new Nodo("Operador suma/resta",null,token);
    opea_sum.addHijo(op.toString(),token);
    expression.addHijo(opea_sum);

    expression.addHijo((Nodo)t);

    RESULT = expression;
:};

termino::= factor:f
{:
    token++;
    Nodo termino= new Nodo("Termino",null,token);

    termino.addHijo((Nodo)f);

    RESULT = termino;
:}
    |   termino:t OPEA_MULT:op factor:f
{:
    token++;
    Nodo termino= new Nodo("Termino",null,0);

    termino.addHijo((Nodo)t);
    
    token++;
    Nodo opea_mult= new Nodo("Operador Mult/Div",null,0);
    opea_mult.addHijo(op.toString(),token);
    termino.addHijo(opea_mult);

    termino.addHijo((Nodo)f);

    RESULT = termino;
:}
    ;

//tener cuidado con el not
factor::= ID:ide
{:
    token++;
    Nodo factor= new Nodo("Factor",null,token);
    
    token++;
    Nodo id= new Nodo("ID",null,token);
    id.addHijo(ide.toString(),token);
    factor.addHijo(id);

    RESULT=factor;
:}
    |   ID:ide PARENTESISA list_expression:list PARENTESISC
{:
    token++;
    Nodo factor= new Nodo("Factor",null,token);

    token++;
    Nodo id= new Nodo("ID",null,token);
    id.addHijo(ide.toString(),token);
    factor.addHijo(id);

    token++;
    Nodo parentesisA= new Nodo("(",null,token);
    factor.addHijo(parentesisA);

    factor.addHijo((Nodo)list);

    token++;
    Nodo parentesisC= new Nodo(")",null,token);
    factor.addHijo(parentesisC);

    RESULT=factor;
:}
    |   valores:v
{:
    token++;
    Nodo factor= new Nodo("Factor",null,token);

    factor.addHijo((Nodo)v);

    RESULT=factor;
:}
    |   PARENTESISA expression:e PARENTESISC
{:
    token++;
    Nodo factor= new Nodo("Factor",null,token);
    
    token++;
    Nodo parentesisA= new Nodo("(",null,token);
    factor.addHijo(parentesisA);
    
    factor.addHijo((Nodo)e);

    token++;
    Nodo parentesisC= new Nodo(")",null,token);
    factor.addHijo(parentesisC);
    
    RESULT=factor;
:}
    |   NOT:n factor:f
{:
    token++;
    Nodo factor= new Nodo("Factor",null,0);

    token++;
    Nodo not= new Nodo("Not",null,token);
    not.addHijo(n.toString(),token);
    factor.addHijo(not);

    factor.addHijo((Nodo)f);
    
    RESULT=factor;
:}
    ;

/*factor_for ::= ID
	| NUM
	| signo NUM;
*/
signo ::= OPEA_SUM:opea_sum
{:
    token++;
    Nodo signo= new Nodo("Signo",null,token);

    token++;
    Nodo op= new Nodo("Operador Suma/Resta",null,token);
    op.addHijo(opea_sum.toString(),token);
    signo.addHijo(op);

    RESULT=signo;
:};

list_expression::= expression:e 
{:
    token++;
    Nodo list=new  Nodo("list_expression",null,token);

    list.addHijo((Nodo)e);

    RESULT=list;
:}
| list_expression:l COMMA expression:e
{:
    token++;
    Nodo list=new  Nodo("list_expression",null,0);

    list.addHijo((Nodo)l);
    
    token++;
    Nodo comma=new  Nodo(",",null,token);
    list.addHijo(comma);
    list.addHijo((Nodo)e);

    RESULT = list;
:};